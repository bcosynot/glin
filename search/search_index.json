{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Seev","text":"<p>Your worklog, without the work.</p> <p>Get Started \u2192 GitHub \u2197</p> <p> </p>"},{"location":"#why-seev","title":"Why Seev","text":"<p>Seev turns your real work\u2014commits, PRs, and AI conversations\u2014into a clean daily worklog. No copy\u2011pasting. No end\u2011of\u2011day scramble.</p> <ul> <li>Manual status updates steal time and are easy to forget.</li> <li>Signals get buried across repos, PRs, and chats.</li> <li>Reviews and performance cycles demand accurate histories.</li> </ul> <p>How Seev helps and what you get: - Automatic capture from git and your AI assistant - Privacy\u2011first and local\u2011first by default - MCP\u2011native: works with Claude Desktop, Cursor, Cline, and more - Fast first success: up and running in minutes</p>"},{"location":"#quick-start-excerpt","title":"Quick Start (excerpt)","text":"<p>Copy these into your terminal:</p>"},{"location":"#1-setup-the-mcp-and-workspace","title":"1. Setup the MCP and workspace","text":"<pre><code>/bin/bash -c \"$(curl -fsSL https://bcosynot.github.io/seev/init.sh)\"\n</code></pre>"},{"location":"#2-add-a-worklog-entry","title":"2. Add a worklog entry","text":"<pre><code>/worklog_entry today\n</code></pre> <p>Tip: After adding Seev to your MCP client config, restart the client to load the server.</p>"},{"location":"#stay-in-the-loop","title":"Stay in the loop","text":"<ul> <li>Docs: Guides \u00b7 Reference</li> <li>GitHub: bcosynot/seev</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for your interest in improving Seev! This guide summarizes how to set up your environment, run tests, and open a high\u2011quality pull request.</p>"},{"location":"contributing/#development-setup","title":"Development setup","text":"<ul> <li>Python 3.13+</li> <li>Package manager: <code>uv</code> (recommended)</li> </ul> <p>Install dependencies (including dev):</p> <pre><code>make sync\n</code></pre> <p>Format and lint:</p> <pre><code>make format\nmake lint\n</code></pre> <p>Run tests (quiet + coverage configured via pyproject):</p> <pre><code>make test\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>We use MkDocs with Material and mkdocstrings.</p> <ul> <li>Build locally with strict checks:</li> </ul> <pre><code>uv run mkdocs build --strict\n</code></pre> <ul> <li>Reference pages pull docstrings directly; keep public functions and return types well\u2011typed.</li> </ul>"},{"location":"contributing/#pr-checklist","title":"PR checklist","text":"<ul> <li>[ ] Tests added or updated; <code>make test</code> passes locally.</li> <li>[ ] Code formatted and linted (<code>make format</code>, <code>make lint</code>).</li> <li>[ ] Docs updated when behavior or public API changes.</li> <li>[ ] Keep changes scoped and well\u2011described in the PR body.</li> </ul>"},{"location":"contributing/#project-conventions","title":"Project conventions","text":"<ul> <li>Type hints: prefer precise TypedDicts or dataclasses for structured results.</li> <li>Tests: pytest + pytest\u2011cov; use monkeypatch for env and filesystem isolation.</li> <li>Tools registration: MCP tools register at import via the shared <code>seev.mcp_app.mcp</code> instance.</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting help","text":"<p>Open an issue in the repository or draft a PR for discussion.</p>"},{"location":"privacy-and-data/","title":"Privacy &amp; Data","text":"<p>Seev is designed with local-first principles:</p> <ul> <li>Local storage by default: Conversations and worklog files are stored on your machine. Git data is read from your local repositories unless you explicitly connect remote services via other MCP servers.</li> <li>No telemetry: The project does not send usage data.</li> </ul>"},{"location":"privacy-and-data/#worklog-location","title":"Worklog location","text":"<p>The markdown worklog file path is resolved by <code>seev.config.get_markdown_path()</code>: - Default: <code>./WORKLOG.md</code> in the current working directory. - Override via env var <code>SEEV_MD_PATH</code>. - Many tools accept an explicit <code>file_path</code> argument that, when provided, takes precedence over env/default.</p>"},{"location":"privacy-and-data/#tracked-identity","title":"Tracked identity","text":"<p>Your commit identity for filtering is resolved by <code>seev.config.get_tracked_emails()</code> with precedence: 1) <code>SEEV_TRACK_EMAILS</code> environment variable (comma-separated) 2) <code>seev.toml</code> at <code>./seev.toml</code>, <code>~/.config/seev/seev.toml</code>, or <code>~/.seev.toml</code> 3) Git fallback: <code>git config --get user.email</code> then <code>git config --get user.name</code></p> <p>Use the <code>configure_tracked_emails</code> MCP tool to set these programmatically.</p>"},{"location":"privacy-and-data/#data-you-control","title":"Data you control","text":"<ul> <li>Conversations: stored locally via <code>seev.storage</code> helpers. You can delete files to erase history.</li> <li>Worklogs: plain Markdown files; edit or remove as you wish.</li> <li>Logs: opt-in file path; delete the log file to clear history.</li> </ul>"},{"location":"privacy-and-data/#external-services","title":"External services","text":"<p>Seev itself does not call remote APIs. If you run your agent with additional MCP servers (e.g., GitHub), those servers have their own privacy characteristics. Review their docs and configure credentials carefully.</p>"},{"location":"troubleshooting/","title":"Troubleshooting &amp; FAQ","text":"<p>Use the links below to jump to specific issues.</p> <ul> <li>fastmcp import error</li> <li>Git repository not found</li> <li>Tracked emails not configured</li> <li>Markdown path problems</li> <li>MkDocs strict build fails</li> </ul>"},{"location":"troubleshooting/#fastmcp-import-error","title":"fastmcp import error","text":"<p>Symptoms: <code>ModuleNotFoundError: No module named 'fastmcp'</code> when running the server.</p> <p>Cause: The runtime environment is missing the FastMCP dependency.</p> <p>Fix: - Run <code>make sync</code> (or <code>uv sync --group dev</code>). - Verify <code>uv run python -c \"import fastmcp; print(fastmcp.__version__)\"</code> works. - In tests, Seev stubs FastMCP automatically; you should not need the package to run unit tests.</p>"},{"location":"troubleshooting/#git-repository-not-found","title":"Git repository not found","text":"<p>Symptoms: Git tools return an error like <code>Not a git repository</code> or empty results.</p> <p>Cause: The <code>workdir</code> argument points outside a git repo, or no repo exists in the current directory.</p> <p>Fix: - Ensure you pass <code>workdir</code> into git MCP tools pointing inside a repo. - Initialize a repo: <code>git init</code> and commit at least once. - Use the Troubleshooting tip in tool descriptions that accept <code>workdir</code>.</p>"},{"location":"troubleshooting/#tracked-emails-not-configured","title":"Tracked emails not configured","text":"<p>Symptoms: Tools that need author filters cannot determine your identity.</p> <p>Cause: No tracked emails were found via env, config file, or git fallback.</p> <p>Fix: - Quick start (env): <code>export SEEV_TRACK_EMAILS=\"user@ex.com,other@ex.com\"</code>. - File-based (recommended for persistence):   - Create <code>seev.toml</code> at project root with:     <pre><code># Seev Configuration\ntrack_emails = [\"user1@example.com\", \"user2@example.com\"]\n</code></pre>   - Or place it at <code>~/.config/seev/seev.toml</code> or <code>~/.seev.toml</code>. - Programmatic: call the <code>configure_tracked_emails</code> MCP tool.</p>"},{"location":"troubleshooting/#markdown-path-problems","title":"Markdown path problems","text":"<p>Symptoms: <code>append_to_markdown</code> writes to an unexpected file, or headings are duplicated.</p> <p>Cause: Mixing <code>SEEV_MD_PATH</code> and explicit <code>file_path</code>, or running on Windows with CRLF newlines in an existing file.</p> <p>Fix: - Prefer a single source of truth: set <code>SEEV_MD_PATH</code> or pass <code>file_path</code>, not both. - The function normalizes to Unix newlines on write; open existing files with a UTF-8 aware editor. - Use <code>read_date_entry</code> to inspect the current structure before writing.</p>"},{"location":"troubleshooting/#mkdocs-strict-build-fails","title":"MkDocs strict build fails","text":"<p>Symptoms: <code>mkdocs build --strict</code> fails due to broken links or import errors.</p> <p>Fix: - Ensure <code>mkdocstrings</code> can import packages: run <code>make sync</code> first. - Verify module names in reference pages are correct (e.g., <code>seev.git_tools.commits</code>). - Check cross-page links (e.g., <code>[MCP Tools](reference/mcp-tools.md)</code>). - Run <code>uv run mkdocs build --strict</code> locally to see detailed errors.</p> <p>Tip: All headings on this page use semantic h2/h3 so anchor links remain stable.</p>"},{"location":"guides/","title":"Guides","text":"<p>Task\u2011oriented guides to get you productive fast. Start with Quick Start, then dive deeper as needed.</p> <ul> <li>Quick Start \u2014 Install, connect to your MCP client, and create your first worklog in \u2264 10 minutes.</li> <li>Workspace &amp; Configuration \u2014 Tracked emails, paths, and environment variables.</li> <li>Generating Worklogs \u2014 Examples\u2011first commands for single days and ranges; correlation behavior.</li> <li>Using Different MCP Clients \u2014 Client\u2011specific setup with config file paths and tips.</li> </ul>"},{"location":"guides/generating-worklogs/","title":"Generating Worklogs","text":"<p>This guide shows practical, copy\u2011pasteable ways to create worklog entries using Seev via your MCP client.</p>"},{"location":"guides/generating-worklogs/#tldr-examples","title":"TL;DR examples","text":"<pre><code>/worklog_entry today\n</code></pre> <pre><code>/worklog_entry 2025-10-20\n</code></pre> <pre><code>/worklog_entry last week\n</code></pre> <pre><code>/worklog_entry 2025-10-15..2025-10-22\n</code></pre> <p>Tip</p> <p>Use natural language: <code>yesterday</code>, <code>last 2 days</code>, <code>1 week ago</code> are all supported.</p>"},{"location":"guides/generating-worklogs/#what-the-assistant-does-under-the-hood","title":"What the assistant does under the hood","text":"<ol> <li>Calls Seev's MCP tools to gather context (commits, conversations, PRs, metrics)</li> <li>Correlates commits with conversations/PRs</li> <li>Generates a structured markdown entry</li> <li>Appends it under <code>## YYYY\u2011MM\u2011DD</code> in your WORKLOG.md</li> </ol>"},{"location":"guides/generating-worklogs/#controlling-scope-with-date-ranges","title":"Controlling scope with date ranges","text":"<ul> <li>Single day: <code>2025-10-22</code> or <code>today</code></li> <li>Relative: <code>last week</code>, <code>last 2 days</code>, <code>1 week ago</code></li> <li>Explicit range: <code>2025-10-15..2025-10-22</code></li> </ul> <p>Examples:</p> <pre><code>/worklog_entry yesterday\n</code></pre> <pre><code>/worklog_entry last 2 days\n</code></pre> <pre><code>/worklog_entry 2025-10-15..2025-10-22\n</code></pre>"},{"location":"guides/generating-worklogs/#adding-your-own-context","title":"Adding your own context","text":"<p>Provide inputs to guide the summary:</p> <pre><code>/worklog_entry today inputs=\"Refactored auth module; fixed checkout bug; reviewed dashboard PR\"\n</code></pre> <p>The assistant will weave your inputs into Goals, Technical Work, and Decisions.</p>"},{"location":"guides/generating-worklogs/#where-entries-are-saved","title":"Where entries are saved","text":"<p>Default path is the workspace worklog file, typically:</p> <pre><code>$ echo $SEEV_MD_PATH\n/home/you/seev-workspace/WORKLOG.md\n</code></pre> <p>Change it by setting <code>SEEV_MD_PATH</code> before launching your client.</p>"},{"location":"guides/generating-worklogs/#correlation-details","title":"Correlation details","text":"<p>Seev enriches entries by:</p> <ul> <li>Matching commits to conversations by time proximity and content hints</li> <li>Detecting PRs for commits when the GitHub MCP is available</li> <li>Computing metrics (additions, deletions, files changed)</li> </ul> <p>See also: MCP Prompts Reference and Workspace &amp; Configuration.</p>"},{"location":"guides/mcp-clients/","title":"Using Different MCP Clients","text":"<p>Configure Seev with your preferred MCP\u2011compatible client. Use the tab for your client and restart it after saving the config.</p> Claude DesktopCursorCline (VS Code) <p>Config file (create if missing):</p> <ul> <li>macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></li> <li>Windows: <code>%APPDATA%\\Claude\\claude_desktop_config.json</code></li> </ul> <pre><code>{\n  \"mcpServers\": {\n    \"seev\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/bcosynot/seev.git\", \"seev\"]\n    }\n  }\n}\n</code></pre> <p>HTTP transport (optional)</p> <p>Seev defaults to stdio. To run over HTTP (port 8000), start it manually:</p> <pre><code>uv run python main.py --transport http\n</code></pre> <p>Config file: - macOS/Linux: <code>~/.cursor/mcp.json</code> - Windows: <code>%USERPROFILE%\\.cursor\\mcp.json</code></p> <pre><code>{\n  \"mcpServers\": {\n    \"seev\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/bcosynot/seev.git\", \"seev\"]\n    }\n  }\n}\n</code></pre> <p>VS Code settings (User or Workspace):</p> <pre><code>{\n  \"cline.mcpServers\": {\n    \"seev\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/bcosynot/seev.git\", \"seev\"]\n    }\n  }\n}\n</code></pre>"},{"location":"guides/mcp-clients/#verifying-your-client-can-talk-to-seev","title":"Verifying your client can talk to Seev","text":"<ul> <li>Restart the client after editing config</li> <li>Ask it to run a simple tool, e.g.:</li> </ul> <pre><code>use seev to get the last 10 commits\n</code></pre> <p>Expected: a configuration snapshot including where tracked emails came from.</p>"},{"location":"guides/quick-start/","title":"Quick Start","text":"<p>Get Seev running and generate your first worklog in \u2264 10 minutes.</p> <p>Tip: Commands first, then explanations. Copy buttons are enabled on this site.</p>"},{"location":"guides/quick-start/#1-prerequisites","title":"1) Prerequisites","text":"<ul> <li>Python 3.13+</li> <li>uv (recommended package runner)</li> <li>git</li> </ul> <p>Verify:</p> <pre><code>python -V\nuv --version\ngit --version\n</code></pre>"},{"location":"guides/quick-start/#2-initialize-your-workspace-12-minutes","title":"2) Initialize your workspace (1\u20132 minutes)","text":"<p>Recommended: use the install script. It prepares a workspace folder, a WORKLOG.md, a local DB, and your Seev config file.</p> <pre><code># Create ~/seev-workspace with sensible defaults\n/bin/bash -c \"$(curl -fsSL https://bcosynot.github.io/seev/init.sh)\"\n</code></pre> <ul> <li>Creates the target dir if missing</li> <li>Writes WORKLOG.md and a local SQLite DB</li> <li>Creates/updates ~/.config/seev/seev.toml with placeholders</li> </ul> <p>Security</p> <p>Always inspect scripts before piping to bash:</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/bcosynot/seev/main/seev-init.sh -o /tmp/seev-init.sh\nless /tmp/seev-init.sh\nbash /tmp/seev-init.sh -h\n</code></pre> <p>Optional flags:</p> <pre><code># Set emails and repos at init time\nbash /tmp/seev-init.sh -y \\\n  -e \"me@ex.com,me@work.com\" \\\n  -r \"org/repo,~/code/another-repo\" \\\n  -m WORKLOG.md -d seev.sqlite3 \\\n  ~/seev-workspace\n</code></pre>"},{"location":"guides/quick-start/#3-add-seev-to-your-mcp-client-24-minutes","title":"3) Add Seev to your MCP client (2\u20134 minutes)","text":"<p>Use one of the tabs below and restart your client after editing its config.</p> Claude DesktopCursorCline (VS Code) <p>Config file paths:</p> <ul> <li>macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></li> <li>Windows: <code>%APPDATA%\\Claude\\claude_desktop_config.json</code></li> </ul> <pre><code>{\n  \"mcpServers\": {\n    \"seev\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/bcosynot/seev.git\", \"seev\"]\n    }\n  }\n}\n</code></pre> <p>Config file path: - macOS/Linux: <code>~/.cursor/mcp.json</code> - Windows: <code>%USERPROFILE%\\.cursor\\mcp.json</code></p> <pre><code>{\n  \"mcpServers\": {\n    \"seev\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/bcosynot/seev.git\", \"seev\"]\n    }\n  }\n}\n</code></pre> <p>VS Code settings JSON (user or workspace):</p> <pre><code>{\n  \"cline.mcpServers\": {\n    \"seev\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/bcosynot/seev.git\", \"seev\"]\n    }\n  }\n}\n</code></pre>"},{"location":"guides/quick-start/#4-generate-your-first-worklog-entry-13-minutes","title":"4) Generate your first worklog entry (1\u20133 minutes)","text":"<p>Open your assistant and run one of these:</p> <pre><code>/worklog_entry today\n</code></pre> <p>Or a specific date or range:</p> <pre><code>/worklog_entry 2025-10-20\n/worklog_entry last week\n</code></pre> <p>What happens: - Seev gathers your commits, correlates with conversations/PRs, and writes to <code>WORKLOG.md</code> under <code>## YYYY-MM-DD</code>.</p>"},{"location":"guides/quick-start/#5-verification-checklist","title":"5) Verification checklist","text":"<ul> <li>[ ] <code>WORKLOG.md</code> exists in your workspace and contains today\u2019s date heading (YYYY-MM-DD).</li> <li>[ ] Entry includes commits and a metrics section.</li> <li>[ ] No client errors after restart; the Seev MCP server shows in logs.</li> </ul> <p>If anything fails, see: Troubleshooting or Workspace &amp; Configuration.</p>"},{"location":"guides/workspace-and-configuration/","title":"Workspace &amp; Configuration","text":"<p>This guide explains how Seev stores data, how to configure tracked emails, and which environment variables and paths control behavior.</p>"},{"location":"guides/workspace-and-configuration/#defaults-at-a-glance","title":"Defaults at a glance","text":"<ul> <li>Workspace directory: you choose (e.g., <code>~/seev-workspace</code>)</li> <li>Worklog file: <code>WORKLOG.md</code> in your workspace</li> <li>Database: <code>db.sqlite3</code> (or <code>seev.sqlite3</code>) in your workspace</li> <li>Config file: <code>~/.config/seev/seev.toml</code></li> </ul>"},{"location":"guides/workspace-and-configuration/#tracked-emails-who-you-are-in-git","title":"Tracked emails (who you are in git)","text":"<p>Seev needs your git author emails to filter commits. Resolution order:</p> <ol> <li><code>SEEV_TRACK_EMAILS</code> environment variable (comma-separated)</li> <li><code>seev.toml</code> at one of:</li> <li><code>./seev.toml</code></li> <li><code>~/.config/seev/seev.toml</code></li> <li><code>~/.seev.toml</code></li> <li>Git fallback: <code>git config --get user.email</code> then <code>git config --get user.name</code></li> </ol> <p>Precedence gotcha</p> <p>The environment variable takes precedence over the config file for the current process. If values look wrong, check <code>SEEV_TRACK_EMAILS</code> first, then your <code>seev.toml</code>.</p>"},{"location":"guides/workspace-and-configuration/#configure-via-environment","title":"Configure via environment","text":"<pre><code>export SEEV_TRACK_EMAILS=\"you@work.com,you@personal.com,handle@users.noreply.github.com\"\n</code></pre>"},{"location":"guides/workspace-and-configuration/#configure-via-file-recommended","title":"Configure via file (recommended)","text":"<p>Create or edit <code>~/.config/seev/seev.toml</code>:</p> <pre><code># Seev Configuration\ntrack_emails = [\n  \"you@work.com\",\n  \"you@personal.com\",\n  \"handle@users.noreply.github.com\",\n]\n</code></pre> <p>Tip</p> <p>You can point your MCP session at specific emails by setting the env var in your shell before launching the client.</p>"},{"location":"guides/workspace-and-configuration/#workspace-paths-and-env-vars","title":"Workspace paths and env vars","text":"<p>The installer creates sensible defaults, but you can override at runtime:</p> <ul> <li><code>SEEV_MD_PATH</code> \u2014 path to your worklog Markdown (default: <code>&lt;workspace&gt;/WORKLOG.md</code>)</li> <li><code>SEEV_DB_PATH</code> \u2014 path to the sqlite database (default: <code>&lt;workspace&gt;/db.sqlite3</code>)</li> <li><code>SEEV_TRACK_EMAILS</code> \u2014 comma-separated emails (overrides file config for the process)</li> </ul> <p>Example:</p> <pre><code>export SEEV_MD_PATH=~/seev-workspace/WORKLOG.md\nexport SEEV_DB_PATH=~/seev-workspace/db.sqlite3\nexport SEEV_TRACK_EMAILS=\"you@work.com,you@personal.com\"\n</code></pre>"},{"location":"guides/workspace-and-configuration/#verifying-configuration-with-mcp-tools","title":"Verifying configuration with MCP tools","text":"<p>From your assistant, ask it to call these tools:</p> <pre><code>/get_tracked_email_config\n</code></pre> <p>Expected: a snapshot of where emails were resolved from and the current values.</p> <pre><code>/configure_tracked_emails method=\"env\" emails=[\"you@work.com\",\"you@personal.com\"]\n</code></pre> <p>Expected: the process env is updated for the MCP server.</p>"},{"location":"guides/workspace-and-configuration/#notes-for-deterministic-tests","title":"Notes for deterministic tests","text":"<p>When writing tests or debugging:</p> <ul> <li>Unset the env var to exercise file/git fallbacks</li> <li>Prefer patching config helpers over invoking <code>git</code> directly</li> <li>Use a temporary directory for any file outputs</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>API and internal module reference for Seev. This section will be populated with mkdocstrings in later phases.</p>"},{"location":"reference/#prompts","title":"Prompts","text":"<p>Server-side assistant prompts available via MCP (overview; detailed docs to be generated in a later phase).</p> <ul> <li>worklog_entry \u2014 generate a structured worklog for a date or range This section is generated via mkdocstrings for the core Python APIs. Use the page ToC to navigate types and functions. See also: MCP Tools and Prompts.</li> </ul>"},{"location":"reference/#configuration","title":"Configuration","text":"<p>Configuration management for Seev.</p> <p>Phase 2 additions: read-only handling of DB/Markdown-related environment flags. - SEEV_DB_PATH: optional filesystem path to the SQLite database file. - SEEV_DB_AUTOWRITE: when truthy, certain integrations may persist data automatically. - SEEV_MD_PATH: optional filesystem path to the Markdown worklog file.</p> <p>Also supports a lightweight <code>seev.toml</code> file with keys: - track_emails = [\"...\"] - track_repositories = [\"...\"] - db_path = \"...\"             # new: database path - markdown_path = \"...\"       # new: markdown file path</p> <p>Backward compatibility: - Legacy glin.toml configuration files are still read if seev.toml is not present.</p>"},{"location":"reference/#seev.config.create_config_file","title":"<code>create_config_file(emails, config_path=None)</code>","text":"<p>Create a glin.toml configuration file with the specified emails.</p> <p>Parameters:</p> Name Type Description Default <code>emails</code> <code>list[str]</code> <p>List of email addresses to track</p> required <code>config_path</code> <code>Path | None</code> <p>Optional path for config file. Defaults to ./glin.toml</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the created configuration file</p> Source code in <code>seev/config.py</code> <pre><code>def create_config_file(emails: list[str], config_path: Path | None = None) -&gt; Path:\n    \"\"\"\n    Create a glin.toml configuration file with the specified emails.\n\n    Args:\n        emails: List of email addresses to track\n        config_path: Optional path for config file. Defaults to ./glin.toml\n\n    Returns:\n        Path to the created configuration file\n    \"\"\"\n    if config_path is None:\n        config_path = Path.cwd() / \"glin.toml\"\n\n    config_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Create TOML content\n    emails_array = \"[\" + \", \".join(f'\"{email}\"' for email in emails) + \"]\"\n    content = f\"\"\"# Glin Configuration\n# List of email addresses to track commits from\ntrack_emails = {emails_array}\n\"\"\"\n\n    config_path.write_text(content)\n    return config_path\n</code></pre>"},{"location":"reference/#seev.config.get_db_autowrite","title":"<code>get_db_autowrite()</code>","text":"<p>Return True if SEEV_DB_AUTOWRITE is a truthy value.</p> <p>Accepted truthy values (case-insensitive): '1', 'true', 'yes', 'on'.</p> Source code in <code>seev/config.py</code> <pre><code>def get_db_autowrite() -&gt; bool:\n    \"\"\"Return True if SEEV_DB_AUTOWRITE is a truthy value.\n\n    Accepted truthy values (case-insensitive): '1', 'true', 'yes', 'on'.\n    \"\"\"\n    val = os.getenv(\"SEEV_DB_AUTOWRITE\")\n    if val is None:\n        return False\n    return val.strip().lower() in {\"1\", \"true\", \"yes\", \"on\"}\n</code></pre>"},{"location":"reference/#seev.config.get_db_path","title":"<code>get_db_path()</code>","text":"<p>Return the DB path to use for SQLite storage.</p> <p>Precedence: 1. SEEV_DB_PATH if set (respects exact value, including \":memory:\") 2. seev.toml key <code>db_path</code> (with glin.toml fallback) 3. Sensible default: ~/.seev/db.sqlite3</p> <p>This function is read-only; it does not create files or directories.</p> Source code in <code>seev/config.py</code> <pre><code>def get_db_path() -&gt; str:\n    \"\"\"Return the DB path to use for SQLite storage.\n\n    Precedence:\n    1. SEEV_DB_PATH if set (respects exact value, including \":memory:\")\n    2. seev.toml key `db_path` (with glin.toml fallback)\n    3. Sensible default: ~/.seev/db.sqlite3\n\n    This function is read-only; it does not create files or directories.\n    \"\"\"\n    value = os.getenv(\"SEEV_DB_PATH\")\n    if value and value.strip():\n        return value.strip()\n    file_val = _get_config_file_value(\"db_path\")\n    if file_val and file_val.strip():\n        return file_val.strip()\n    # Default to a stable path in user home for CI and local runs.\n    return \"~/.seev/db.sqlite3\"\n</code></pre>"},{"location":"reference/#seev.config.get_markdown_path","title":"<code>get_markdown_path()</code>","text":"<p>Return the Markdown worklog path.</p> <p>Precedence: 1. SEEV_MD_PATH if set 2. seev.toml key <code>markdown_path</code> (with glin.toml fallback) 3. Default: ./WORKLOG.md</p> Source code in <code>seev/config.py</code> <pre><code>def get_markdown_path() -&gt; str:\n    \"\"\"Return the Markdown worklog path.\n\n    Precedence:\n    1. SEEV_MD_PATH if set\n    2. seev.toml key `markdown_path` (with glin.toml fallback)\n    3. Default: ./WORKLOG.md\n    \"\"\"\n    value = os.getenv(\"SEEV_MD_PATH\")\n    if value and value.strip():\n        return value.strip()\n    file_val = _get_config_file_value(\"markdown_path\")\n    if file_val and file_val.strip():\n        return file_val.strip()\n    return \"WORKLOG.md\"\n</code></pre>"},{"location":"reference/#seev.config.get_tracked_emails","title":"<code>get_tracked_emails()</code>","text":"<p>Get the list of email addresses to track commits from.</p> <p>Priority order: 1. SEEV_TRACK_EMAILS environment variable (comma-separated) 2. seev.toml configuration file (with glin.toml fallback) 3. Git user.email configuration 4. Git user.name configuration (as fallback)</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of email addresses/patterns to track. Empty list if none configured.</p> Source code in <code>seev/config.py</code> <pre><code>def get_tracked_emails() -&gt; list[str]:\n    \"\"\"\n    Get the list of email addresses to track commits from.\n\n    Priority order:\n    1. SEEV_TRACK_EMAILS environment variable (comma-separated)\n    2. seev.toml configuration file (with glin.toml fallback)\n    3. Git user.email configuration\n    4. Git user.name configuration (as fallback)\n\n    Returns:\n        List of email addresses/patterns to track. Empty list if none configured.\n    \"\"\"\n    # 1. Check environment variable first\n    env_emails = os.getenv(\"SEEV_TRACK_EMAILS\")\n    if env_emails:\n        return [email.strip() for email in env_emails.split(\",\") if email.strip()]\n\n    # 2. Check for configuration file\n    config_emails = _get_config_file_emails()\n    if config_emails:\n        return config_emails\n\n    # 3. Fallback to git configuration\n    git_pattern = _get_git_author_pattern()\n    if git_pattern:\n        return [git_pattern]\n\n    return []\n</code></pre>"},{"location":"reference/#seev.config.get_tracked_repositories","title":"<code>get_tracked_repositories()</code>","text":"<p>Return the list of repositories to include when building worklogs.</p> <p>Accepted formats per entry: - Local filesystem path to a Git repo - GitHub shorthand \"owner/repo\" - Full Git remote URL (https or ssh)</p> <p>Precedence: 1. SEEV_TRACK_REPOSITORIES (comma-separated) [fallback: SEEV_TRACK_REPOS] 2. seev.toml key track_repositories = [\"...\"] (with glin.toml fallback)</p> Source code in <code>seev/config.py</code> <pre><code>def get_tracked_repositories() -&gt; list[str]:\n    \"\"\"\n    Return the list of repositories to include when building worklogs.\n\n    Accepted formats per entry:\n    - Local filesystem path to a Git repo\n    - GitHub shorthand \"owner/repo\"\n    - Full Git remote URL (https or ssh)\n\n    Precedence:\n    1. SEEV_TRACK_REPOSITORIES (comma-separated) [fallback: SEEV_TRACK_REPOS]\n    2. seev.toml key track_repositories = [\"...\"] (with glin.toml fallback)\n    \"\"\"\n    env_val = os.getenv(\"SEEV_TRACK_REPOSITORIES\") or os.getenv(\"SEEV_TRACK_REPOS\")\n    if env_val:\n        return [v.strip() for v in env_val.split(\",\") if v.strip()]\n    file_repos = _get_config_file_repositories()\n    if file_repos:\n        return file_repos\n    return []\n</code></pre>"},{"location":"reference/#seev.config.set_tracked_emails_env","title":"<code>set_tracked_emails_env(emails)</code>","text":"<p>Set the SEEV_TRACK_EMAILS environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>emails</code> <code>list[str]</code> <p>List of email addresses to track</p> required Source code in <code>seev/config.py</code> <pre><code>def set_tracked_emails_env(emails: list[str]) -&gt; None:\n    \"\"\"\n    Set the SEEV_TRACK_EMAILS environment variable.\n\n    Args:\n        emails: List of email addresses to track\n    \"\"\"\n    value = \",\".join(emails)\n    os.environ[\"SEEV_TRACK_EMAILS\"] = value\n</code></pre>"},{"location":"reference/#seev.config.set_tracked_repositories_env","title":"<code>set_tracked_repositories_env(repositories)</code>","text":"<p>Set SEEV_TRACK_REPOSITORIES environment variable to a comma-separated list.</p> Source code in <code>seev/config.py</code> <pre><code>def set_tracked_repositories_env(repositories: list[str]) -&gt; None:\n    \"\"\"Set SEEV_TRACK_REPOSITORIES environment variable to a comma-separated list.\"\"\"\n    os.environ[\"SEEV_TRACK_REPOSITORIES\"] = \",\".join(repositories)\n</code></pre>"},{"location":"reference/#markdown-utilities","title":"Markdown Utilities","text":""},{"location":"reference/#seev.markdown_tools.DateEntryResponse","title":"<code>DateEntryResponse</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Response from reading a date entry.</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>class DateEntryResponse(TypedDict):\n    \"\"\"Response from reading a date entry.\"\"\"\n\n    exists: bool\n    date: str\n    heading_line: int | None\n    sections: DateEntrySections\n    raw_content: str\n</code></pre>"},{"location":"reference/#seev.markdown_tools.DateEntrySections","title":"<code>DateEntrySections</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parsed sections from a date entry.</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>class DateEntrySections(TypedDict):\n    \"\"\"Parsed sections from a date entry.\"\"\"\n\n    goals: list[str]\n    technical: list[str]\n    metrics: list[str]\n    decisions: list[str]\n    impact: list[str]\n    open_items: list[str]\n    learnings: list[str]\n    weekly_summary: str | None\n</code></pre>"},{"location":"reference/#seev.markdown_tools.MarkdownErrorResponse","title":"<code>MarkdownErrorResponse</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Error response from markdown operation.</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>class MarkdownErrorResponse(TypedDict):\n    \"\"\"Error response from markdown operation.\"\"\"\n\n    error: str\n</code></pre>"},{"location":"reference/#seev.markdown_tools.MarkdownSuccessResponse","title":"<code>MarkdownSuccessResponse</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Successful markdown append operation response.</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>class MarkdownSuccessResponse(TypedDict):\n    \"\"\"Successful markdown append operation response.\"\"\"\n\n    ok: bool\n    path: str\n    bullets_added: int\n    content_added: list[str]\n    line_numbers_added: list[int]\n    heading: str\n    heading_added: bool\n    heading_line_number: int | None\n    used_env: bool\n    defaulted: bool\n    update_mode_used: bool\n    existing_bullets_preserved: int\n    new_bullets_added: int\n    deduplicated_count: int\n</code></pre>"},{"location":"reference/#seev.markdown_tools.append_to_markdown","title":"<code>append_to_markdown(content, file_path=None, date_str=None, *, preserve_lines=False, update_mode=False)</code>","text":"<p>Append content under a date heading in a markdown file.</p> <p>Behavior: - Default (preserve_lines=False): Each non-empty input line becomes a markdown bullet   (\"- ...\"). - Raw mode (preserve_lines=True): Lines are written as-is (no automatic bullet prefix).   Useful for writing headings like \"### Goals\". - Update mode (update_mode=True): Read existing entry for the date and merge new content   with existing sections instead of appending. - Ensures a heading for the specified date (\"## YYYY-MM-DD\"). If no date is provided, uses   the current local date. Creates it if missing. - Appends content under the chosen date's heading, before the next heading or at the end. - Path resolution: file_path argument &gt; SEEV_MD_PATH env var &gt; seev.toml <code>markdown_path</code>   (with glin.toml fallback) &gt; ./WORKLOG.md.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text to append. Must be non-empty (after stripping). Newlines will be normalized.</p> required <code>file_path</code> <code>str | None</code> <p>Optional target file path. Can be absolute or relative to the repo root.</p> <code>None</code> <code>date_str</code> <code>str | None</code> <p>Optional date string in ISO format (YYYY-MM-DD). When provided, content is added under this date's heading instead of today's.</p> <code>None</code> <code>preserve_lines</code> <code>bool</code> <p>When True, write lines as-is; when False, prefix each non-empty line with \"- \".</p> <code>False</code> <code>update_mode</code> <code>bool</code> <p>When True, read existing entry for the date and merge new content with existing sections instead of appending. When False (default), append as before (backward compatible).</p> <code>False</code> <p>Returns:</p> Type Description <code>MarkdownSuccessResponse | MarkdownErrorResponse</code> <p>A dict with operation details or an error message, including the exact content and</p> <code>MarkdownSuccessResponse | MarkdownErrorResponse</code> <p>line numbers added.</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>def append_to_markdown(\n    content: str,\n    file_path: str | None = None,\n    date_str: str | None = None,\n    *,\n    preserve_lines: bool = False,\n    update_mode: bool = False,\n) -&gt; MarkdownSuccessResponse | MarkdownErrorResponse:\n    \"\"\"\n    Append content under a date heading in a markdown file.\n\n    Behavior:\n    - Default (preserve_lines=False): Each non-empty input line becomes a markdown bullet\n      (\"- ...\").\n    - Raw mode (preserve_lines=True): Lines are written as-is (no automatic bullet prefix).\n      Useful for writing headings like \"### Goals\".\n    - Update mode (update_mode=True): Read existing entry for the date and merge new content\n      with existing sections instead of appending.\n    - Ensures a heading for the specified date (\"## YYYY-MM-DD\"). If no date is provided, uses\n      the current local date. Creates it if missing.\n    - Appends content under the chosen date's heading, before the next heading or at the end.\n    - Path resolution: file_path argument &gt; SEEV_MD_PATH env var &gt; seev.toml `markdown_path`\n      (with glin.toml fallback) &gt; ./WORKLOG.md.\n\n    Args:\n        content: The text to append. Must be non-empty (after stripping). Newlines will be\n            normalized.\n        file_path: Optional target file path. Can be absolute or relative to the repo root.\n        date_str: Optional date string in ISO format (YYYY-MM-DD). When provided, content is\n            added under this date's heading instead of today's.\n        preserve_lines: When True, write lines as-is; when False, prefix each non-empty line\n            with \"- \".\n        update_mode: When True, read existing entry for the date and merge new content with\n            existing sections instead of appending. When False (default), append as before\n            (backward compatible).\n\n    Returns:\n        A dict with operation details or an error message, including the exact content and\n        line numbers added.\n    \"\"\"\n    try:\n        if content is None or str(content).strip() == \"\":\n            error_response: MarkdownErrorResponse = {\n                \"error\": \"content is required and cannot be empty\"\n            }\n            return error_response\n\n        from datetime import date, datetime\n\n        # Resolve target path: parameter &gt; env var &gt; glin.toml &gt; default\n        if file_path and str(file_path).strip():\n            target = str(file_path).strip()\n            used_env_flag = False\n            defaulted_flag = False\n        else:\n            # Delegate env/TOML/default resolution to config\n            target = get_markdown_path()\n            used_env_flag = bool(os.getenv(\"SEEV_MD_PATH\"))\n            # Consider defaulted when neither param nor env provided and config didn't override\n            defaulted_flag = (not used_env_flag) and (target == \"WORKLOG.md\")\n        path = Path(target)\n        if not path.is_absolute():\n            path = Path.cwd() / path\n\n        # Ensure parent directory exists\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Prepare date heading (validate provided date_str if any)\n        if date_str is not None:\n            try:\n                # Validate format using fromisoformat; it raises ValueError for invalid strings\n                chosen_date: date = date.fromisoformat(date_str)\n            except ValueError:\n                return {\"error\": \"date_str must be in YYYY-MM-DD format\"}\n            date_for_heading = chosen_date.isoformat()\n        else:\n            date_for_heading = datetime.now().date().isoformat()\n\n        # UPDATE MODE: Read existing entry and merge\n        if update_mode:\n            existing = read_date_entry(date_for_heading, file_path)\n\n            if existing[\"exists\"]:\n                # Merge new content with existing\n                merged_content, deduplicated_count = merge_date_sections(\n                    existing, content, preserve_lines=preserve_lines\n                )\n\n                # Read the file to replace the date section\n                if path.exists():\n                    file_content = (\n                        path.read_text(encoding=\"utf-8\").replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n                    )\n                    doc_lines = file_content.split(\"\\n\")\n                    if doc_lines and doc_lines[-1] == \"\":\n                        doc_lines.pop()\n                else:\n                    doc_lines = []\n\n                # Find the date heading\n                heading = f\"## {date_for_heading}\"\n                heading_idx = None\n                for i, line in enumerate(doc_lines):\n                    if line.strip() == heading:\n                        heading_idx = i\n                        break\n\n                # Find the end of this date section\n                end_idx = len(doc_lines)\n                if heading_idx is not None:\n                    for i in range(heading_idx + 1, len(doc_lines)):\n                        stripped = doc_lines[i].strip()\n                        # Match only level 2 headings (## ), not level 3 (###) or deeper\n                        if stripped.startswith(\"## \") and len(stripped) &gt; 3:\n                            end_idx = i\n                            break\n\n                    # Replace the section content (keep heading, replace content\n                    # until the next heading)\n                    merged_lines = merged_content.split(\"\\n\")\n                    # Remove leading empty line if present (we'll add proper spacing)\n                    while merged_lines and merged_lines[0].strip() == \"\":\n                        merged_lines.pop(0)\n\n                    # Ensure blank line after heading\n                    replacement = [\"\"]\n                    replacement.extend(merged_lines)\n\n                    # Ensure blank line before next heading if there is one\n                    if end_idx &lt; len(doc_lines):\n                        replacement.append(\"\")\n\n                    # Replace content between heading and next section\n                    doc_lines[heading_idx + 1 : end_idx] = replacement\n\n                    # Count bullets in merged content\n                    bullet_count = sum(1 for line in merged_lines if line.strip().startswith(\"- \"))\n\n                    # Reconstruct and write\n                    new_content = \"\\n\".join(doc_lines)\n                    if not new_content.endswith(\"\\n\"):\n                        new_content += \"\\n\"\n                    path.write_text(new_content, encoding=\"utf-8\")\n\n                    # Calculate statistics\n                    existing_bullet_count = sum(\n                        len(bullets)\n                        for bullets in existing[\"sections\"].values()\n                        if isinstance(bullets, list)\n                    )\n                    new_bullets_added = bullet_count - existing_bullet_count + deduplicated_count\n\n                    success_response: MarkdownSuccessResponse = {\n                        \"ok\": True,\n                        \"path\": str(path),\n                        \"bullets_added\": bullet_count,\n                        \"content_added\": merged_lines,\n                        \"line_numbers_added\": list(\n                            range(heading_idx + 2, heading_idx + 2 + len(merged_lines))\n                        ),\n                        \"heading\": heading,\n                        \"heading_added\": False,\n                        \"heading_line_number\": heading_idx + 1,\n                        \"used_env\": used_env_flag,\n                        \"defaulted\": defaulted_flag,\n                        \"update_mode_used\": True,\n                        \"existing_bullets_preserved\": existing_bullet_count,\n                        \"new_bullets_added\": new_bullets_added,\n                        \"deduplicated_count\": deduplicated_count,\n                    }\n                    return success_response\n            # If no existing entry, fall through to normal append logic below\n\n        # Normalize input newlines to Unix and split into lines\n        text = str(content).replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n        lines = [\n            ln.rstrip() for ln in text.split(\"\\n\")\n        ]  # preserve leading '#' etc.; strip right only\n        # Build the block lines according to mode\n        if preserve_lines:\n            block_lines = [ln for ln in lines if ln.strip() != \"\"]\n        else:\n            block_lines = [f\"- {ln.strip()}\" for ln in lines if ln.strip() != \"\"]\n        if not block_lines:\n            error_response: MarkdownErrorResponse = {\"error\": \"content contained only blank lines\"}\n            return error_response\n\n        heading = f\"## {date_for_heading}\"\n\n        # Read existing file (normalize to Unix newlines)\n        existing = \"\"\n        if path.exists():\n            existing = path.read_text(encoding=\"utf-8\").replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n        # Ensure file ends with single newline for consistent processing\n        if existing and not existing.endswith(\"\\n\"):\n            existing += \"\\n\"\n\n        # Work with list of lines for insertion\n        doc_lines = existing.split(\"\\n\") if existing else []\n        # Remove a possible trailing empty string from split if file ended with newline\n        if doc_lines and doc_lines[-1] == \"\":\n            doc_lines.pop()\n\n        # Find today's heading\n        try:\n            heading_idx = next(i for i, ln in enumerate(doc_lines) if ln.strip() == heading)\n            heading_exists = True\n        except StopIteration:\n            heading_exists = False\n            heading_idx = None\n\n        # If heading is missing, append it at end with proper spacing\n        if not heading_exists:\n            # Ensure blank line before new heading if file not empty and last line not blank\n            if doc_lines and doc_lines[-1].strip() != \"\":\n                doc_lines.append(\"\")\n            doc_lines.append(heading)\n            doc_lines.append(\"\")  # blank line after heading\n            # After appending, recalculate heading index\n\n        # Determine insertion index: after the heading and any existing content of that section,\n        # which we define as lines until the next heading (line starting with '#').\n        # Recompute heading index to be robust\n        heading_idx = next((i for i, ln in enumerate(doc_lines) if ln.strip() == heading), None)\n        if heading_idx is None:\n            # Fallback: append heading at end if somehow missing\n            if doc_lines and doc_lines[-1].strip() != \"\":\n                doc_lines.append(\"\")\n            doc_lines.append(heading)\n            doc_lines.append(\"\")\n            heading_idx = len(doc_lines) - 2  # index of heading line\n            heading_exists = False\n\n        # Find next heading after current section\n        next_heading_idx = None\n        for i in range(heading_idx + 1, len(doc_lines)):\n            if doc_lines[i].lstrip().startswith(\"#\") and doc_lines[i].strip() != \"\":\n                next_heading_idx = i\n                break\n\n        # Build the new section content to insert\n        insert_block = []\n        # Ensure there is a blank line after heading if the next line isn't blank\n        # and we're inserting directly\n        after_heading_idx = heading_idx + 1\n        if after_heading_idx &gt;= len(doc_lines) or doc_lines[after_heading_idx].strip() != \"\":\n            insert_block.append(\"\")\n        insert_block.extend(block_lines)\n\n        # If there will be another heading after, ensure there is a blank line before it\n        if next_heading_idx is not None:\n            insert_block.append(\"\")\n\n        # Compute insertion position\n        insert_pos = next_heading_idx if next_heading_idx is not None else len(doc_lines)\n\n        # Determine the 1-based line numbers for the bullets we will insert\n        # First, compute where within insert_block the bullets start\n        bullets_offset_in_block = 1 if (len(insert_block) &gt; 0 and insert_block[0] == \"\") else 0\n        bullet_line_numbers = []\n        # The final line number for a given inserted line at block index k is (insert_pos + k) + 1\n        for idx in range(len(block_lines)):\n            k = bullets_offset_in_block + idx\n            bullet_line_numbers.append(insert_pos + k + 1)\n\n        # If we created the heading in this call, compute its 1-based line number\n        # in the final document\n        heading_added = not heading_exists\n        heading_line_number = None\n        if heading_added:\n            # Heading line is at heading_idx (recomputed above) in doc_lines\n            # BEFORE inserting insert_block\n            # Since we haven't yet inserted insert_block, its final 1-based line\n            # number is heading_idx + 1\n            heading_line_number = heading_idx + 1\n\n        # Insert bullets block\n        doc_lines[insert_pos:insert_pos] = insert_block\n\n        # Reconstruct content with Unix newlines and ensure file ends with newline\n        new_content = \"\".join(line + \"\\n\" for line in doc_lines)\n        if not new_content.endswith(\"\\n\"):\n            new_content += \"\\n\"\n\n        path.write_text(new_content, encoding=\"utf-8\")\n\n        success_response: MarkdownSuccessResponse = {\n            \"ok\": True,\n            \"path\": str(path),\n            \"bullets_added\": len(block_lines),\n            \"content_added\": block_lines,\n            \"line_numbers_added\": bullet_line_numbers,\n            \"heading\": heading,\n            \"heading_added\": heading_added,\n            \"heading_line_number\": heading_line_number,\n            \"used_env\": used_env_flag,\n            \"defaulted\": defaulted_flag,\n            \"update_mode_used\": False,\n            \"existing_bullets_preserved\": 0,\n            \"new_bullets_added\": len(block_lines),\n            \"deduplicated_count\": 0,\n        }\n        return success_response\n    except Exception as e:\n        error_response: MarkdownErrorResponse = {\"error\": f\"Failed to append to markdown: {e}\"}\n        return error_response\n</code></pre>"},{"location":"reference/#seev.markdown_tools.merge_date_sections","title":"<code>merge_date_sections(existing, new_content, *, preserve_lines=False)</code>","text":"<p>Merge new content with existing date entry sections.</p> <p>Parameters:</p> Name Type Description Default <code>existing</code> <code>DateEntryResponse</code> <p>Result from read_date_entry</p> required <code>new_content</code> <code>str</code> <p>New markdown content to merge (with ### sections)</p> required <code>preserve_lines</code> <code>bool</code> <p>Same semantics as append_to_markdown</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, int]</code> <p>Tuple of (merged markdown content ready to write, deduplicated count)</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>def merge_date_sections(\n    existing: DateEntryResponse,\n    new_content: str,\n    *,\n    preserve_lines: bool = False,\n) -&gt; tuple[str, int]:\n    \"\"\"\n    Merge new content with existing date entry sections.\n\n    Args:\n        existing: Result from read_date_entry\n        new_content: New markdown content to merge (with ### sections)\n        preserve_lines: Same semantics as append_to_markdown\n\n    Returns:\n        Tuple of (merged markdown content ready to write, deduplicated count)\n    \"\"\"\n    # Parse new content into sections\n    new_sections: DateEntrySections = {\n        \"goals\": [],\n        \"technical\": [],\n        \"metrics\": [],\n        \"decisions\": [],\n        \"impact\": [],\n        \"open_items\": [],\n        \"learnings\": [],\n        \"weekly_summary\": None,\n    }\n\n    # Normalize and split new content\n    text = str(new_content).replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n    lines = [ln.rstrip() for ln in text.split(\"\\n\")]\n\n    # Section patterns (same as read_date_entry)\n    section_patterns = {\n        \"goals\": r\"###\\s*\ud83c\udfaf\\s*Goals?\\s*(&amp;\\s*Context)?\",\n        \"technical\": r\"###\\s*\ud83d\udcbb\\s*Technical\\s*Work\",\n        \"metrics\": r\"###\\s*\ud83d\udcca\\s*Metrics?\",\n        \"decisions\": r\"###\\s*\ud83d\udd0d\\s*Key\\s*Decisions?\",\n        \"impact\": r\"###\\s*\u26a0\ufe0f\\s*Impact\\s*Assessment\",\n        \"open_items\": r\"###\\s*\ud83d\udea7\\s*Open\\s*Items?\",\n        \"learnings\": r\"###\\s*\ud83d\udcda\\s*Learnings?\",\n        \"weekly_summary\": r\"###\\s*\ud83d\uddd3\ufe0f\\s*Weekly\\s*Summary\",\n    }\n\n    current_section = None\n    weekly_summary_lines = []\n\n    for line in lines:\n        # Check if this line starts a new section\n        matched_section = None\n        for section_key, pattern in section_patterns.items():\n            if re.match(pattern, line.strip(), re.IGNORECASE):\n                matched_section = section_key\n                break\n\n        if matched_section:\n            current_section = matched_section\n            if current_section == \"weekly_summary\":\n                weekly_summary_lines = []\n        elif current_section:\n            stripped = line.strip()\n            if current_section == \"weekly_summary\":\n                weekly_summary_lines.append(line)\n            elif stripped.startswith(\"- \"):\n                bullet_content = stripped[2:].strip()\n                if bullet_content:\n                    new_sections[current_section].append(bullet_content)\n            elif stripped.startswith(\"* \"):\n                bullet_content = stripped[2:].strip()\n                if bullet_content:\n                    new_sections[current_section].append(bullet_content)\n            elif preserve_lines and stripped:\n                # In preserve_lines mode, include non-bullet lines too\n                new_sections[current_section].append(stripped)\n\n    if weekly_summary_lines:\n        new_sections[\"weekly_summary\"] = \"\\n\".join(weekly_summary_lines).strip()\n\n    # Merge sections with deduplication\n    merged_sections: DateEntrySections = {\n        \"goals\": [],\n        \"technical\": [],\n        \"metrics\": [],\n        \"decisions\": [],\n        \"impact\": [],\n        \"open_items\": [],\n        \"learnings\": [],\n        \"weekly_summary\": None,\n    }\n\n    total_duplicates = 0\n\n    # Merge each section with appropriate strategy\n    for section_key in [\"goals\", \"decisions\", \"impact\", \"open_items\", \"learnings\"]:\n        merged_sections[section_key], dupes = _deduplicate_bullets(\n            existing[\"sections\"][section_key], new_sections[section_key]\n        )\n        total_duplicates += dupes\n\n    # Technical section: deduplicate by commit hash\n    merged_sections[\"technical\"], dupes = _deduplicate_commits(\n        existing[\"sections\"][\"technical\"], new_sections[\"technical\"]\n    )\n    total_duplicates += dupes\n\n    # Metrics: prefer new (recalculated) over existing\n    merged_sections[\"metrics\"] = (\n        new_sections[\"metrics\"] if new_sections[\"metrics\"] else existing[\"sections\"][\"metrics\"]\n    )\n\n    # Weekly summary: preserve existing unless new one provided\n    if new_sections[\"weekly_summary\"]:\n        merged_sections[\"weekly_summary\"] = new_sections[\"weekly_summary\"]\n    else:\n        merged_sections[\"weekly_summary\"] = existing[\"sections\"][\"weekly_summary\"]\n\n    # Reconstruct markdown content\n    output_lines = []\n\n    # Add sections in standard order\n    section_order = [\n        (\"goals\", \"### \ud83c\udfaf Goals &amp; Context\"),\n        (\"technical\", \"### \ud83d\udcbb Technical Work\"),\n        (\"metrics\", \"### \ud83d\udcca Metrics\"),\n        (\"decisions\", \"### \ud83d\udd0d Key Decisions\"),\n        (\"impact\", \"### \u26a0\ufe0f Impact Assessment\"),\n        (\"open_items\", \"### \ud83d\udea7 Open Items\"),\n        (\"learnings\", \"### \ud83d\udcda Learnings\"),\n    ]\n\n    for section_key, section_heading in section_order:\n        bullets = merged_sections[section_key]\n        if bullets:\n            output_lines.append(\"\")\n            output_lines.append(section_heading)\n            output_lines.append(\"\")\n            for bullet in bullets:\n                output_lines.append(f\"- {bullet}\")\n\n    # Add weekly summary if present\n    if merged_sections[\"weekly_summary\"]:\n        output_lines.append(\"\")\n        output_lines.append(\"### \ud83d\uddd3\ufe0f Weekly Summary\")\n        output_lines.append(\"\")\n        # Weekly summary content already formatted\n        for line in merged_sections[\"weekly_summary\"].split(\"\\n\"):\n            output_lines.append(line)\n\n    # Join with newlines\n    merged_content = \"\\n\".join(output_lines)\n\n    return merged_content, total_duplicates\n</code></pre>"},{"location":"reference/#seev.markdown_tools.read_date_entry","title":"<code>read_date_entry(date_str, file_path=None)</code>","text":"<p>Read and parse an existing date entry from the markdown file.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date in ISO format (YYYY-MM-DD) to search for.</p> required <code>file_path</code> <code>str | None</code> <p>Optional target file path. Uses same resolution as append_to_markdown.</p> <code>None</code> <p>Returns:</p> Type Description <code>DateEntryResponse</code> <p>A dict with exists flag, date, heading line number, parsed sections, and raw content.</p> <code>DateEntryResponse</code> <p>If the date entry doesn't exist, returns exists=False with empty sections.</p> Source code in <code>seev/markdown_tools.py</code> <pre><code>def read_date_entry(\n    date_str: str,\n    file_path: str | None = None,\n) -&gt; DateEntryResponse:\n    \"\"\"\n    Read and parse an existing date entry from the markdown file.\n\n    Args:\n        date_str: Date in ISO format (YYYY-MM-DD) to search for.\n        file_path: Optional target file path. Uses same resolution as append_to_markdown.\n\n    Returns:\n        A dict with exists flag, date, heading line number, parsed sections, and raw content.\n        If the date entry doesn't exist, returns exists=False with empty sections.\n    \"\"\"\n    from datetime import date\n\n    # Validate date format\n    try:\n        parsed_date = date.fromisoformat(date_str)\n        date_iso = parsed_date.isoformat()\n    except ValueError:\n        # Return non-existent entry for invalid date\n        return {\n            \"exists\": False,\n            \"date\": date_str,\n            \"heading_line\": None,\n            \"sections\": {\n                \"goals\": [],\n                \"technical\": [],\n                \"metrics\": [],\n                \"decisions\": [],\n                \"impact\": [],\n                \"open_items\": [],\n                \"learnings\": [],\n                \"weekly_summary\": None,\n            },\n            \"raw_content\": \"\",\n        }\n\n    # Resolve target path using same logic as append_to_markdown\n    if file_path and str(file_path).strip():\n        target = str(file_path).strip()\n    else:\n        target = get_markdown_path()\n    path = Path(target)\n    if not path.is_absolute():\n        path = Path.cwd() / path\n\n    # If file doesn't exist, return non-existent entry\n    if not path.exists():\n        return {\n            \"exists\": False,\n            \"date\": date_iso,\n            \"heading_line\": None,\n            \"sections\": {\n                \"goals\": [],\n                \"technical\": [],\n                \"metrics\": [],\n                \"decisions\": [],\n                \"impact\": [],\n                \"open_items\": [],\n                \"learnings\": [],\n                \"weekly_summary\": None,\n            },\n            \"raw_content\": \"\",\n        }\n\n    # Read and normalize file content\n    content = path.read_text(encoding=\"utf-8\").replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n    lines = content.split(\"\\n\")\n\n    # Find the date heading\n    heading = f\"## {date_iso}\"\n    heading_idx = None\n    for i, line in enumerate(lines):\n        if line.strip() == heading:\n            heading_idx = i\n            break\n\n    # If heading not found, return non-existent entry\n    if heading_idx is None:\n        return {\n            \"exists\": False,\n            \"date\": date_iso,\n            \"heading_line\": None,\n            \"sections\": {\n                \"goals\": [],\n                \"technical\": [],\n                \"metrics\": [],\n                \"decisions\": [],\n                \"impact\": [],\n                \"open_items\": [],\n                \"learnings\": [],\n                \"weekly_summary\": None,\n            },\n            \"raw_content\": \"\",\n        }\n\n    # Find the end of this date section (next ## heading or end of file)\n    end_idx = len(lines)\n    for i in range(heading_idx + 1, len(lines)):\n        stripped = lines[i].strip()\n        # Match only level 2 headings (## ), not level 3 (###) or deeper\n        if stripped.startswith(\"## \") and len(stripped) &gt; 3:\n            end_idx = i\n            break\n\n    # Extract raw content for this date section\n    section_lines = lines[heading_idx + 1 : end_idx]\n    raw_content = \"\\n\".join(section_lines)\n\n    # Parse sections by ### headings with emoji markers\n    sections: DateEntrySections = {\n        \"goals\": [],\n        \"technical\": [],\n        \"metrics\": [],\n        \"decisions\": [],\n        \"impact\": [],\n        \"open_items\": [],\n        \"learnings\": [],\n        \"weekly_summary\": None,\n    }\n\n    # Section markers (emoji + text patterns)\n    section_patterns = {\n        \"goals\": r\"###\\s*\ud83c\udfaf\\s*Goals?\\s*(&amp;\\s*Context)?\",\n        \"technical\": r\"###\\s*\ud83d\udcbb\\s*Technical\\s*Work\",\n        \"metrics\": r\"###\\s*\ud83d\udcca\\s*Metrics?\",\n        \"decisions\": r\"###\\s*\ud83d\udd0d\\s*Key\\s*Decisions?\",\n        \"impact\": r\"###\\s*\u26a0\ufe0f\\s*Impact\\s*Assessment\",\n        \"open_items\": r\"###\\s*\ud83d\udea7\\s*Open\\s*Items?\",\n        \"learnings\": r\"###\\s*\ud83d\udcda\\s*Learnings?\",\n        \"weekly_summary\": r\"###\\s*\ud83d\uddd3\ufe0f\\s*Weekly\\s*Summary\",\n    }\n\n    current_section = None\n    weekly_summary_lines = []\n\n    for line in section_lines:\n        # Check if this line starts a new section\n        matched_section = None\n        for section_key, pattern in section_patterns.items():\n            if re.match(pattern, line.strip(), re.IGNORECASE):\n                matched_section = section_key\n                break\n\n        if matched_section:\n            current_section = matched_section\n            if current_section == \"weekly_summary\":\n                weekly_summary_lines = []\n        elif current_section:\n            # Extract content based on section type\n            stripped = line.strip()\n            if current_section == \"weekly_summary\":\n                # Collect all lines for weekly summary\n                weekly_summary_lines.append(line)\n            elif stripped.startswith(\"- \"):\n                # Extract bullet content (remove \"- \" prefix)\n                bullet_content = stripped[2:].strip()\n                if bullet_content:\n                    sections[current_section].append(bullet_content)\n            elif stripped.startswith(\"* \"):\n                # Also handle * bullets\n                bullet_content = stripped[2:].strip()\n                if bullet_content:\n                    sections[current_section].append(bullet_content)\n\n    # Set weekly summary if any content was collected\n    if weekly_summary_lines:\n        sections[\"weekly_summary\"] = \"\\n\".join(weekly_summary_lines).strip()\n\n    return {\n        \"exists\": True,\n        \"date\": date_iso,\n        \"heading_line\": heading_idx + 1,  # 1-based line number\n        \"sections\": sections,\n        \"raw_content\": raw_content,\n    }\n</code></pre>"},{"location":"reference/#git-tools","title":"Git Tools","text":""},{"location":"reference/#branches","title":"Branches","text":""},{"location":"reference/#commits","title":"Commits","text":""},{"location":"reference/#files","title":"Files","text":""},{"location":"reference/#diffs","title":"Diffs","text":""},{"location":"reference/#remotes","title":"Remotes","text":""},{"location":"reference/#seev.git_tools.remotes.determine_commit_url_prefix","title":"<code>determine_commit_url_prefix(remote_url)</code>","text":"<p>Given a Git remote URL, derive the HTTPS commit URL prefix for common hosts.</p> <p>Supported providers and their commit URL patterns: - GitHub:    https://///commit/ - GitLab:    https://///-/commit/ - Bitbucket: https://///commits/ <p>Returns {\"prefix\": \"...\"} or {\"error\": \"...\"} when unknown or unparseable.</p> Source code in <code>seev/git_tools/remotes.py</code> <pre><code>def determine_commit_url_prefix(remote_url: str | None) -&gt; CommitUrlPrefixResult:\n    \"\"\"\n    Given a Git remote URL, derive the HTTPS commit URL prefix for common hosts.\n\n    Supported providers and their commit URL patterns:\n    - GitHub:    https://&lt;host&gt;/&lt;owner&gt;/&lt;repo&gt;/commit/\n    - GitLab:    https://&lt;host&gt;/&lt;owner&gt;/&lt;repo&gt;/-/commit/\n    - Bitbucket: https://&lt;host&gt;/&lt;owner&gt;/&lt;repo&gt;/commits/\n\n    Returns {\"prefix\": \"...\"} or {\"error\": \"...\"} when unknown or unparseable.\n    \"\"\"\n    if not remote_url:\n        return {\"error\": \"remote_url is required\"}\n\n    url = remote_url.strip()\n    host: str | None = None\n    path: str | None = None\n\n    try:\n        # SSH formats\n        # - git@host:owner/repo.git\n        # - ssh://git@host/owner/repo.git\n        if url.startswith(\"ssh://\"):\n            rest = url.split(\"://\", 1)[1]\n            # Remove optional user@\n            if \"@\" in rest:\n                rest = rest.split(\"@\", 1)[1]\n            if \"/\" in rest:\n                host, path = rest.split(\"/\", 1)\n        elif \"@\" in url and \":\" in url and url.split(\"@\", 1)[0].isidentifier():\n            # Likely git@host:owner/repo.git (simple heuristic)\n            user_host, path = url.split(\":\", 1)\n            host = user_host.split(\"@\", 1)[1]\n        # HTTPS/HTTP format: https://host/owner/repo(.git)\n        elif url.startswith(\"http://\") or url.startswith(\"https://\"):\n            rest = url.split(\"://\", 1)[1]\n            if \"/\" in rest:\n                host, path = rest.split(\"/\", 1)\n        else:\n            return {\"error\": \"Unrecognized remote URL format\"}\n\n        if not host or not path:\n            return {\"error\": \"Remote URL missing host or path\"}\n\n        # Normalize path: drop leading slashes and trailing .git\n        path = path.lstrip(\"/\")\n        if path.endswith(\".git\"):\n            path = path[:-4]\n\n        # In practice, we expect owner/repo; if more segments exist, keep them as-is.\n        base = f\"https://{host}/{path}\"\n        host_l = host.lower()\n        if host_l == \"github.com\" or \"github.\" in host_l:\n            return {\"prefix\": base + \"/commit/\"}\n        if host_l == \"gitlab.com\" or \"gitlab.\" in host_l:\n            return {\"prefix\": base + \"/-/commit/\"}\n        if host_l == \"bitbucket.org\" or \"bitbucket.\" in host_l:\n            return {\"prefix\": base + \"/commits/\"}\n        return {\"error\": \"Unknown host for commit URL prefix\"}\n    except Exception as e:  # pragma: no cover - be defensive in tool\n        return {\"error\": f\"Failed to parse remote URL: {str(e)}\"}\n</code></pre>"},{"location":"reference/#seev.git_tools.remotes.get_remote_origin","title":"<code>get_remote_origin(workdir=None)</code>","text":"<p>Return information about the remote named 'origin' for the current repository.</p> <p>On success: {\"name\": \"origin\", \"url\": \"...\"} On failure: {\"error\": \"...\"}</p> Source code in <code>seev/git_tools/remotes.py</code> <pre><code>def get_remote_origin(workdir: str | None = None) -&gt; RemoteInfo:\n    \"\"\"\n    Return information about the remote named 'origin' for the current repository.\n\n    On success: {\"name\": \"origin\", \"url\": \"...\"}\n    On failure: {\"error\": \"...\"}\n    \"\"\"\n    try:\n        # Resolve repo root only when an explicit workdir is provided to preserve default behavior\n        repo_root: str | None = None\n        if workdir is not None:\n            root_res = resolve_repo_root(workdir)\n            if \"error\" in root_res:\n                return {\"error\": root_res[\"error\"]}\n            repo_root = root_res.get(\"path\")\n\n        if repo_root:\n            res = run_git([\"remote\", \"get-url\", \"origin\"], repo_root=repo_root)\n        else:\n            res = subprocess.run(\n                [\"git\", \"remote\", \"get-url\", \"origin\"], capture_output=True, text=True, check=True\n            )\n        url = (res.stdout or \"\").strip()\n        if not url:\n            return {\"error\": \"Remote 'origin' has no URL configured\"}\n        return {\"name\": \"origin\", \"url\": url}\n    except subprocess.CalledProcessError as e:  # noqa: BLE001\n        # Git returns non-zero if origin does not exist or repo is not a git repo\n        err = (e.stderr or \"\").strip() or (e.stdout or \"\").strip()\n        if not err:\n            err = \"Git command failed\"\n        return {\"error\": err}\n    except Exception as e:  # noqa: BLE001\n        return {\"error\": f\"Failed to get remote origin: {str(e)}\"}\n</code></pre>"},{"location":"reference/#analysis","title":"Analysis","text":""},{"location":"reference/#seev.git_tools.analysis.blame_file","title":"<code>blame_file(path, start_line=1, end_line=None, rev='HEAD', workdir=None)</code>","text":"<p>Run git blame on a file or a line range.</p> <p>Returns a structured list with commit, author, date and code for each line.</p> Source code in <code>seev/git_tools/analysis.py</code> <pre><code>def blame_file(\n    path: str,\n    start_line: int = 1,\n    end_line: int | None = None,\n    rev: str = \"HEAD\",\n    workdir: str | None = None,\n) -&gt; dict:\n    \"\"\"Run git blame on a file or a line range.\n\n    Returns a structured list with commit, author, date and code for each line.\n    \"\"\"\n    try:\n        repo_root: str | None = None\n        if workdir is not None:\n            root_res = resolve_repo_root(workdir)\n            if \"error\" in root_res:\n                return _err(root_res[\"error\"])\n            repo_root = root_res.get(\"path\")\n\n        args = [\"blame\", rev, \"--line-porcelain\"]\n        if end_line is not None:\n            args += [f\"-L{start_line},{end_line}\"]\n        elif start_line != 1:\n            args += [f\"-L{start_line},+999999\"]\n        args.append(path)\n        res = run_git(args, repo_root=repo_root)\n        lines = res.stdout.splitlines()\n\n        entries: list[dict] = []\n        cur: dict | None = None\n        for ln in lines:\n            if re.match(r\"^[0-9a-f]{7,40} \", ln):\n                # start of a block\n                if cur:\n                    entries.append(cur)\n                parts = ln.split()\n                cur = {\n                    \"commit\": parts[0],\n                    \"orig_line\": int(parts[2]) if len(parts) &gt; 2 else None,\n                    \"final_line\": int(parts[1]) if len(parts) &gt; 1 else None,\n                    \"author\": None,\n                    \"author_mail\": None,\n                    \"author_time\": None,\n                    \"summary\": None,\n                    \"code\": None,\n                }\n            elif ln.startswith(\"author \") and cur is not None:\n                cur[\"author\"] = ln[len(\"author \") :]\n            elif ln.startswith(\"author-mail \") and cur is not None:\n                cur[\"author_mail\"] = ln[len(\"author-mail \") :].strip(\"&lt;&gt;\")\n            elif ln.startswith(\"author-time \") and cur is not None:\n                cur[\"author_time\"] = int(ln[len(\"author-time \") :])\n            elif ln.startswith(\"summary \") and cur is not None:\n                cur[\"summary\"] = ln[len(\"summary \") :]\n            elif ln.startswith(\"\\t\") and cur is not None:\n                cur[\"code\"] = ln[1:]\n        if cur:\n            entries.append(cur)\n        return {\"path\": path, \"rev\": rev, \"start\": start_line, \"end\": end_line, \"entries\": entries}\n    except subprocess.CalledProcessError as e:  # noqa: BLE001\n        return _err(f\"Git command failed: {e.stderr}\")\n    except Exception as e:  # noqa: BLE001\n        return _err(f\"Failed to run git blame: {str(e)}\")\n</code></pre>"},{"location":"reference/#seev.git_tools.analysis.categorize_commit","title":"<code>categorize_commit(message_or_hash, is_hash=False, workdir=None)</code>","text":"<p>Categorize a commit message using Conventional Commits.</p> <p>If is_hash=True, the argument is treated as a commit hash and its subject is resolved first.</p> Source code in <code>seev/git_tools/analysis.py</code> <pre><code>def categorize_commit(\n    message_or_hash: str, is_hash: bool = False, workdir: str | None = None\n) -&gt; Categorization | ErrorResponse:\n    \"\"\"Categorize a commit message using Conventional Commits.\n\n    If is_hash=True, the argument is treated as a commit hash and its subject is resolved first.\n    \"\"\"\n    try:\n        raw = _get_commit_message(message_or_hash, workdir=workdir) if is_hash else message_or_hash\n        m = _CONVENTIONAL_RE.match(raw)\n        if not m:\n            return {\n                \"type\": \"other\",\n                \"scope\": None,\n                \"description\": raw,\n                \"conventional\": False,\n                \"raw\": raw,\n                **({\"hash\": message_or_hash} if is_hash else {}),\n            }\n        ctype_raw = m.group(\"type\")\n        ctype = ctype_raw.lower()\n        scope = m.group(\"scope\")\n        desc = m.group(\"desc\")\n        conventional = ctype in _CONVENTIONAL_TYPES\n        return {\n            \"type\": ctype,\n            \"scope\": scope,\n            \"description\": desc,\n            \"conventional\": conventional,\n            \"raw\": raw,\n            **({\"hash\": message_or_hash} if is_hash else {}),\n        }\n    except subprocess.CalledProcessError as e:  # noqa: BLE001\n        return _err(f\"Git command failed: {e.stderr}\")\n    except Exception as e:  # noqa: BLE001\n        return _err(f\"Failed to categorize commit: {str(e)}\")\n</code></pre>"},{"location":"reference/#seev.git_tools.analysis.detect_merge_info","title":"<code>detect_merge_info(commit_hash, workdir=None)</code>","text":"<p>Detect whether a commit is a merge, and whether it's a PR merge.</p> <p>Heuristics for PR merges: - Subject contains \"Merge pull request #\" (GitHub) - Subject starts with \"Merge branch\" (generic) \u2192 not necessarily a PR - Two or more parents in <code>git rev-list --parents -n 1</code> Source code in <code>seev/git_tools/analysis.py</code> <pre><code>def detect_merge_info(commit_hash: str, workdir: str | None = None) -&gt; MergeInfo | ErrorResponse:\n    \"\"\"Detect whether a commit is a merge, and whether it's a PR merge.\n\n    Heuristics for PR merges:\n    - Subject contains \"Merge pull request #&lt;n&gt;\" (GitHub)\n    - Subject starts with \"Merge branch\" (generic) \u2192 not necessarily a PR\n    - Two or more parents in `git rev-list --parents -n 1`\n    \"\"\"\n    try:\n        repo_root: str | None = None\n        if workdir is not None:\n            root_res = resolve_repo_root(workdir)\n            if \"error\" in root_res:\n                return _err(root_res[\"error\"])\n            repo_root = root_res.get(\"path\")\n\n        parents_res = run_git(\n            [\"rev-list\", \"--parents\", \"-n\", \"1\", commit_hash], repo_root=repo_root\n        )\n        parts = parents_res.stdout.strip().split()\n        if not parts:\n            return _err(f\"Commit {commit_hash} not found\")\n        _hash, *parents = parts\n        message = _get_commit_message(commit_hash, workdir=workdir)\n\n        is_merge = len(parents) &gt;= 2\n        pr_number: int | None = None\n        is_pr_merge = False\n\n        m = re.search(r\"Merge pull request #(\\d+)\", message, flags=re.IGNORECASE)\n        if m:\n            pr_number = int(m.group(1))\n            is_pr_merge = True\n        elif is_merge and message.lower().startswith(\"merge branch\"):\n            is_pr_merge = False\n\n        return {\n            \"hash\": commit_hash,\n            \"parents\": parents,\n            \"is_merge\": is_merge,\n            \"is_pr_merge\": is_pr_merge,\n            \"pr_number\": pr_number,\n            \"message\": message,\n        }\n    except subprocess.CalledProcessError as e:  # noqa: BLE001\n        return _err(f\"Git command failed: {e.stderr}\")\n    except Exception as e:  # noqa: BLE001\n        return _err(f\"Failed to detect merge info: {str(e)}\")\n</code></pre>"},{"location":"reference/#seev.git_tools.analysis.get_commit_statistics","title":"<code>get_commit_statistics(commit_hash, workdir=None)</code>","text":"<p>Aggregate simple statistics for a commit, including language breakdown.</p> <p>Uses <code>git show --numstat</code> and infers language from file extensions.</p> Source code in <code>seev/git_tools/analysis.py</code> <pre><code>def get_commit_statistics(\n    commit_hash: str, workdir: str | None = None\n) -&gt; CommitStats | ErrorResponse:\n    \"\"\"Aggregate simple statistics for a commit, including language breakdown.\n\n    Uses `git show --numstat` and infers language from file extensions.\n    \"\"\"\n    try:\n        repo_root: str | None = None\n        if workdir is not None:\n            root_res = resolve_repo_root(workdir)\n            if \"error\" in root_res:\n                return _err(root_res[\"error\"])\n            repo_root = root_res.get(\"path\")\n\n        numstat = run_git(\n            [\"show\", \"--numstat\", \"--pretty=format:\", commit_hash], repo_root=repo_root\n        )\n        additions = 0\n        deletions = 0\n        files_changed = 0\n        lang_data: dict[str, dict[str, int]] = defaultdict(\n            lambda: {\"additions\": 0, \"deletions\": 0, \"files\": 0}\n        )\n\n        for line in numstat.stdout.strip().split(\"\\n\"):\n            if not line:\n                continue\n            parts = line.split(\"\\t\")\n            if len(parts) &lt; 3:\n                continue\n            add_s, del_s, path = parts[0], parts[1], parts[2]\n            add = 0 if add_s == \"-\" else int(add_s)\n            delete = 0 if del_s == \"-\" else int(del_s)\n            additions += add\n            deletions += delete\n            files_changed += 1\n\n            lang = _infer_language(path)\n            d = lang_data[lang]\n            d[\"additions\"] += add\n            d[\"deletions\"] += delete\n            d[\"files\"] += 1\n\n        return {\n            \"hash\": commit_hash,\n            \"additions\": additions,\n            \"deletions\": deletions,\n            \"files_changed\": files_changed,\n            \"by_language\": dict(lang_data),\n        }\n    except subprocess.CalledProcessError as e:  # noqa: BLE001\n        return _err(f\"Git command failed: {e.stderr}\")\n    except Exception as e:  # noqa: BLE001\n        return _err(f\"Failed to compute commit statistics: {str(e)}\")\n</code></pre>"},{"location":"reference/#enrichment","title":"Enrichment","text":""},{"location":"reference/#seev.git_tools.enrichment.get_enriched_commits","title":"<code>get_enriched_commits(workdir, since, until='now')</code>","text":"<p>Return commits within a date range enriched with analysis metadata.</p> <p>Adds per-commit statistics, conventional commit categorization, and merge/PR detection.</p> <p>When the underlying commit query returns informational or error items (e.g., no configured emails, or no commits in range), forward that response directly for the caller to handle. Otherwise, return a structured object with commits and aggregated totals.</p> Source code in <code>seev/git_tools/enrichment.py</code> <pre><code>def get_enriched_commits(\n    workdir: str, since: str, until: str = \"now\"\n) -&gt; EnrichedResult | list[dict]:\n    \"\"\"Return commits within a date range enriched with analysis metadata.\n\n    Adds per-commit statistics, conventional commit categorization, and merge/PR detection.\n\n    When the underlying commit query returns informational or error items (e.g.,\n    no configured emails, or no commits in range), forward that response directly\n    for the caller to handle. Otherwise, return a structured object with commits\n    and aggregated totals.\n    \"\"\"\n    commits = get_commits_by_date(workdir, since, until)\n\n    # Forward-through behavior for non-standard responses\n    if not isinstance(commits, list) or not commits:\n        return commits  # type: ignore[return-value]\n\n    if commits and isinstance(commits[0], dict) and (\"error\" in commits[0] or \"info\" in commits[0]):\n        return commits  # type: ignore[return-value]\n\n    enriched: list[EnrichedCommit] = []\n\n    total_adds = 0\n    total_dels = 0\n    total_files = 0\n\n    for c in commits:\n        # Skip non-commit dicts defensively\n        if \"hash\" not in c:\n            continue\n\n        sha = c[\"hash\"]\n        stats = get_commit_statistics(sha, workdir=workdir)\n        category = categorize_commit(sha, is_hash=True, workdir=workdir)\n        merge_info = detect_merge_info(sha, workdir=workdir)\n\n        # Aggregate totals if stats have expected shape\n        try:\n            total_adds += int(stats.get(\"additions\", 0))  # type: ignore[arg-type]\n            total_dels += int(stats.get(\"deletions\", 0))  # type: ignore[arg-type]\n            total_files += int(stats.get(\"files_changed\", 0))  # type: ignore[arg-type]\n        except Exception:\n            # Keep going even if stats are partially missing\n            pass\n\n        enriched.append(\n            EnrichedCommit(\n                **c,  # type: ignore[arg-type]\n                statistics=stats,  # type: ignore[arg-type]\n                category=category,  # type: ignore[arg-type]\n                merge_info=merge_info,  # type: ignore[arg-type]\n            )\n        )\n\n    return EnrichedResult(\n        commits=enriched,\n        totals=EnrichmentTotals(\n            additions=total_adds,\n            deletions=total_dels,\n            files_changed=total_files,\n        ),\n        generated_at=datetime.now().isoformat(),\n    )\n</code></pre>"},{"location":"reference/#sessions","title":"Sessions","text":""},{"location":"reference/#seev.git_tools.sessions.detect_work_sessions","title":"<code>detect_work_sessions(commits, gap_threshold_minutes=30)</code>","text":"<p>Group commits into logical work sessions.</p> <p>Heuristics: - Time gaps greater than <code>gap_threshold_minutes</code> start a new session - Primary type inferred from enriched <code>category.type</code> when present - Simple theme inferred from most common non-trivial words in messages</p> <p>The function is tolerant to mixed commit dict shapes. If commits are not enriched, it still works using basic fields (<code>date</code>, <code>message</code>, etc.).</p> Source code in <code>seev/git_tools/sessions.py</code> <pre><code>def detect_work_sessions(commits: list[dict], gap_threshold_minutes: int = 30) -&gt; list[WorkSession]:\n    \"\"\"Group commits into logical work sessions.\n\n    Heuristics:\n    - Time gaps greater than ``gap_threshold_minutes`` start a new session\n    - Primary type inferred from enriched ``category.type`` when present\n    - Simple theme inferred from most common non-trivial words in messages\n\n    The function is tolerant to mixed commit dict shapes. If commits are not\n    enriched, it still works using basic fields (``date``, ``message``, etc.).\n    \"\"\"\n    if not commits:\n        return []\n\n    # Sort by date (ISO-like string accepted). Tests ensure date is present.\n    sorted_commits = sorted(commits, key=lambda c: c.get(\"date\", \"\"))\n\n    sessions: list[WorkSession] = []\n    current: dict[str, Any] = {\"commits\": [], \"start_time\": None, \"end_time\": None}\n\n    for c in sorted_commits:\n        date_str = str(c.get(\"date\", \"\"))\n        if not date_str:\n            # Skip items that don't look like commits\n            continue\n        # Normalize: allow \"YYYY-MM-DD HH:MM:SS\" or isoformat already\n        ts = datetime.fromisoformat(date_str.replace(\" \", \"T\"))\n\n        if current[\"start_time\"] is None:\n            current[\"start_time\"] = ts\n            current[\"end_time\"] = ts\n            current[\"commits\"].append(c)\n            continue\n\n        gap_min = (ts - current[\"end_time\"]).total_seconds() / 60.0\n        if gap_min &gt; gap_threshold_minutes:\n            sessions.append(_finalize_session(current))\n            current = {\"commits\": [c], \"start_time\": ts, \"end_time\": ts}\n        else:\n            current[\"commits\"].append(c)\n            current[\"end_time\"] = ts\n\n    if current[\"commits\"]:\n        sessions.append(_finalize_session(current))\n\n    return sessions\n</code></pre>"},{"location":"reference/#seev.git_tools.sessions.get_work_sessions","title":"<code>get_work_sessions(since, until='now', gap_threshold_minutes=30)</code>","text":"<p>High-level API to compute sessions for a date range.</p> <p>Prefers enriched commits for better type detection; falls back to raw commits when enrichment returns an error/info payload.</p> Source code in <code>seev/git_tools/sessions.py</code> <pre><code>def get_work_sessions(\n    since: str, until: str = \"now\", gap_threshold_minutes: int = 30\n) -&gt; WorkSessionsResult | list[dict]:\n    \"\"\"High-level API to compute sessions for a date range.\n\n    Prefers enriched commits for better type detection; falls back to raw commits\n    when enrichment returns an error/info payload.\n    \"\"\"\n    data: EnrichedResult | list[dict] = get_enriched_commits(since, until)\n\n    commits: list[dict]\n    if isinstance(data, list):\n        # error/info passthrough; also handle empty\n        return data\n    else:\n        commits = data.get(\"commits\", [])\n        if not commits:\n            # try fallback to raw commits for robustness\n            raw = get_commits_by_date(since, until)\n            if isinstance(raw, list) and raw and not (\"error\" in raw[0] or \"info\" in raw[0]):\n                commits = raw  # type: ignore[assignment]\n            else:\n                return raw  # type: ignore[return-value]\n\n    sessions = detect_work_sessions(commits, gap_threshold_minutes=gap_threshold_minutes)\n\n    return WorkSessionsResult(\n        sessions=sessions,\n        commit_count=len([c for c in commits if isinstance(c, dict) and c.get(\"hash\")]),\n        generated_at=datetime.now().isoformat(),\n    )\n</code></pre>"},{"location":"reference/#config-tools","title":"Config Tools","text":""},{"location":"reference/mcp-tools/","title":"MCP Tools Reference","text":"<p>This page documents the MCP tools exposed by Seev. Each tool includes a brief purpose, arguments, an example call, and return shape. For full Python signatures and types, see the API reference pages linked inline.</p> <p>Tip: Tools names match the decorators in the code (mcp.tool). You can discover them at runtime from the FastMCP client.</p>"},{"location":"reference/mcp-tools/#conversations","title":"Conversations","text":""},{"location":"reference/mcp-tools/#record_conversation_message","title":"record_conversation_message","text":"<ul> <li>Purpose: Record a message in a coding conversation. Creates the conversation if conversation_id is omitted.</li> <li>Args:</li> <li>role: string, e.g. \"user\", \"assistant\", \"system\".</li> <li>content: string message body.</li> <li>conversation_id: integer or null.</li> <li>title: optional string, used when creating a new conversation.</li> <li>Returns: object with conversation_id, message_id, role, content_length, title, created_new_conversation.</li> <li>See code: seev.conversation_tools.record_conversation_message.</li> </ul>"},{"location":"reference/mcp-tools/#get_recent_conversations","title":"get_recent_conversations","text":"<ul> <li>Purpose: List recent conversations with message counts and a preview.</li> <li>Args:</li> <li>date: optional ISO date (YYYY-MM-DD). Filters to that day.</li> <li>limit: max items to return (default 10).</li> <li>Returns: list of conversations with message_count and first_message fields.</li> <li>See code: seev.conversation_tools.get_recent_conversations.</li> </ul>"},{"location":"reference/mcp-tools/#git-commits-and-branches","title":"Git \u2014 Commits and Branches","text":""},{"location":"reference/mcp-tools/#get_recent_commits","title":"get_recent_commits","text":"<ul> <li>Purpose: Recent commits for the current repo (or workdir), most recent first.</li> <li>Key args: workdir (path), max_count (int).</li> <li>Returns: list of commit dicts (hash, author, date, message ...).</li> <li>See code: seev.git_tools.commits.get_recent_commits.</li> </ul>"},{"location":"reference/mcp-tools/#get_commits_by_date","title":"get_commits_by_date","text":"<ul> <li>Purpose: Commits within a date/time window or human-friendly range.</li> <li>Key args: since, until, branch (optional), workdir.</li> <li>Returns: list of commits or an info entry if none found.</li> <li>See code: seev.git_tools.commits.get_commits_by_date.</li> </ul>"},{"location":"reference/mcp-tools/#get_branch_commits","title":"get_branch_commits","text":"<ul> <li>Purpose: Commits on a specific branch.</li> <li>Key args: branch (name), since/until (optional), workdir.</li> <li>See code: seev.git_tools.commits.get_branch_commits.</li> </ul>"},{"location":"reference/mcp-tools/#list_branches","title":"list_branches","text":"<ul> <li>Purpose: List local branches with ahead/behind counts vs default.</li> <li>Key args: workdir.</li> <li>Returns: list of branches with status.</li> <li>See code: seev.git_tools.branches.list_branches.</li> </ul>"},{"location":"reference/mcp-tools/#get_current_branch","title":"get_current_branch","text":"<ul> <li>Purpose: Return the current branch name.</li> <li>Key args: workdir.</li> <li>Returns: { name } or an error object.</li> <li>See code: seev.git_tools.branches.get_current_branch.</li> </ul>"},{"location":"reference/mcp-tools/#git-files-diffs-remotes","title":"Git \u2014 Files, Diffs, Remotes","text":""},{"location":"reference/mcp-tools/#get_commit_files","title":"get_commit_files","text":"<ul> <li>Purpose: Files changed in a commit.</li> <li>Args: commit (hash), workdir.</li> <li>Returns: list of file paths + stats.</li> <li>See code: seev.git_tools.files.get_commit_files.</li> </ul>"},{"location":"reference/mcp-tools/#get_commit_diff","title":"get_commit_diff","text":"<ul> <li>Purpose: Unified diff for a commit (or commit range).</li> <li>Args: commit (hash or range), workdir.</li> <li>Returns: text diff or structured summary.</li> <li>See code: seev.git_tools.diffs.get_commit_diff.</li> </ul>"},{"location":"reference/mcp-tools/#get_remote_origin","title":"get_remote_origin","text":"<ul> <li>Purpose: Read the repository origin URL.</li> <li>Args: workdir.</li> <li>Returns: url string or error.</li> <li>See code: seev.git_tools.remotes.get_remote_origin.</li> </ul>"},{"location":"reference/mcp-tools/#determine_commit_url_prefix","title":"determine_commit_url_prefix","text":"<ul> <li>Purpose: Normalize a remote URL to a web commit URL prefix for linking (e.g., https://host/owner/repo/commit/).</li> <li>Args: remote_url string.</li> <li>Returns: url_prefix or empty when unknown.</li> <li>See code: seev.git_tools.remotes.determine_commit_url_prefix.</li> </ul>"},{"location":"reference/mcp-tools/#git-analysis-enrichment","title":"Git \u2014 Analysis &amp; Enrichment","text":""},{"location":"reference/mcp-tools/#get_enriched_commits","title":"get_enriched_commits","text":"<ul> <li>Purpose: Add stats like additions/deletions and files changed to commits.</li> <li>Args: commits (list) or an implicit range via since/until; workdir.</li> <li>Returns: list of enriched commit dicts.</li> <li>See code: seev.git_tools.enrichment.get_enriched_commits.</li> </ul>"},{"location":"reference/mcp-tools/#detect_merge_info","title":"detect_merge_info","text":"<ul> <li>Purpose: Parse merge commit messages to extract PR number and branch info.</li> <li>Args: message (string).</li> <li>Returns: object with pr_number, source_branch, target_branch when found.</li> <li>See code: seev.git_tools.analysis.detect_merge_info.</li> </ul>"},{"location":"reference/mcp-tools/#get_commit_statistics","title":"get_commit_statistics","text":"<ul> <li>Purpose: Aggregate totals (additions/deletions, file counts) for a commit list.</li> <li>Args: commits (list).</li> <li>Returns: object with totals.</li> <li>See code: seev.git_tools.analysis.get_commit_statistics.</li> </ul>"},{"location":"reference/mcp-tools/#categorize_commit","title":"categorize_commit","text":"<ul> <li>Purpose: Lightweight heuristic categorization (feature, fix, docs, chore...).</li> <li>Args: message (string).</li> <li>Returns: category string.</li> <li>See code: seev.git_tools.analysis.categorize_commit.</li> </ul>"},{"location":"reference/mcp-tools/#git_blame","title":"git_blame","text":"<ul> <li>Purpose: Annotate a file with blame metadata.</li> <li>Args: path (file), rev (optional), workdir.</li> <li>Returns: list of line annotations.</li> <li>See code: seev.git_tools.analysis.git_blame.</li> </ul>"},{"location":"reference/mcp-tools/#git-sessions","title":"Git \u2014 Sessions","text":""},{"location":"reference/mcp-tools/#get_work_sessions","title":"get_work_sessions","text":"<ul> <li>Purpose: Rough session clusters from commit timestamps.</li> <li>Args: commits (list) or since/until, threshold_minutes (gap size), workdir.</li> <li>Returns: list of sessions with start/end/commit_count.</li> <li>See code: seev.git_tools.sessions.get_work_sessions.</li> </ul>"},{"location":"reference/mcp-tools/#configuration-tools","title":"Configuration Tools","text":""},{"location":"reference/mcp-tools/#get_tracked_email_config","title":"get_tracked_email_config","text":"<ul> <li>Purpose: Show the current tracked email configuration and its source.</li> <li>Returns: snapshot object.</li> <li>See code: seev.git_tools.config_tools.get_tracked_email_config.</li> </ul>"},{"location":"reference/mcp-tools/#get_tracked_repositories_config","title":"get_tracked_repositories_config","text":"<ul> <li>Purpose: List repositories to include in worklogs.</li> <li>Returns: object with tracked_repositories, count, and source.</li> <li>See code: seev.git_tools.config_tools.get_tracked_repositories_config.</li> </ul>"},{"location":"reference/mcp-tools/#configure_tracked_emails","title":"configure_tracked_emails","text":"<ul> <li>Purpose: Set tracked emails via env or file.</li> <li>Args: method (\"env\"|\"file\"), emails (list), optional path for file.</li> <li>Returns: confirmation object.</li> <li>See code: seev.git_tools.config_tools.configure_tracked_emails.</li> </ul>"},{"location":"reference/mcp-tools/#markdown-tools","title":"Markdown Tools","text":""},{"location":"reference/mcp-tools/#read_date_entry","title":"read_date_entry","text":"<ul> <li>Purpose: Read one date section from the worklog file.</li> <li>Args: date_str, file_path (optional), env var SEEV_MD_PATH respected.</li> <li>Returns: structured object including lines and positions.</li> <li>See code: seev.markdown_tools.read_date_entry.</li> </ul>"},{"location":"reference/mcp-tools/#append_to_markdown","title":"append_to_markdown","text":"<ul> <li>Purpose: Append or update a date section in the worklog (idempotent merge when update_mode=true).</li> <li>Args: date_str, content, preserve_lines (bool), update_mode (bool), file_path optional.</li> <li>Returns: rich result dict (path, bullets added, line numbers, heading_added, etc.).</li> <li>See code: seev.markdown_tools.append_to_markdown.</li> </ul>"},{"location":"reference/mcp-tools/#worklog-scaffolding","title":"Worklog &amp; Scaffolding","text":""},{"location":"reference/mcp-tools/#generate_rich_worklog","title":"generate_rich_worklog","text":"<ul> <li>Purpose: Server-side synthesis of rich worklog content from inputs and tools (not used by worklog_entry prompt; see prompt docs).</li> <li>Args: since/until or date, inputs text.</li> <li>Returns: generated markdown.</li> <li>See code: seev.worklog_generator.generate_rich_worklog.</li> </ul>"},{"location":"reference/mcp-tools/#init_glin","title":"init_glin","text":"<ul> <li>Purpose: Initialize a workspace with Seev scaffolding.</li> <li>Returns: paths created and next steps.</li> <li>See code: seev.scaffold_tools.init_glin.</li> </ul>"},{"location":"reference/prompts/","title":"Prompts Reference","text":"<p>This page documents server-side prompts exposed via the MCP Prompts API. These prompts do not call LLMs; they return message sequences your client can feed to an LLM.</p>"},{"location":"reference/prompts/#worklog_entry","title":"worklog_entry","text":"<ul> <li>Purpose: Generate an engineering worklog entry for a given day or period. If tool-calling is available, it orchestrates Git and GitHub data gathering before synthesis and then persists the result into your worklog file.</li> <li>Arguments:</li> <li>date (string): Target day or period. Accepts YYYY-MM-DD, a range (YYYY-MM-DD..YYYY-MM-DD), or relative expressions like \"yesterday\", \"last 2 days\".</li> <li>inputs (string, optional): Free-text notes to incorporate.</li> <li>Behavior highlights:</li> <li>Gathers commits per repository using git MCP tools (get_commits_by_date, get_enriched_commits, get_remote_origin, determine_commit_url_prefix).</li> <li>Correlates commits with conversations (get_recent_conversations) and with pull requests when PR numbers are found.</li> <li>Produces structured sections: Goals &amp; Context, Technical Work, Metrics, Key Decisions, Impact, Open Items, Learnings.</li> <li>Persists one block per date by calling append_to_markdown with update_mode=true so entries merge idempotently.</li> <li>Optionally writes a Weekly Summary for the Monday..Sunday window when a full week has completed and there are newer entries past the Sunday.</li> <li>Returns: list of messages like [{\"role\": \"system\"|\"user\", \"content\": \"...\"}] suitable for your LLM client.</li> <li>See code: seev.prompts.worklog_entry_prompt.</li> </ul>"},{"location":"reference/prompts/#slash-command-usage","title":"Slash command usage","text":"<ul> <li>Syntax: <code>/worklog_entry &lt;date&gt; [inputs]</code></li> <li>Positional arguments: <code>date</code> is required; <code>inputs</code> is optional.</li> <li>Quoting: wrap strings that contain spaces in quotes. Double or single quotes are both allowed.</li> <li>Spacing: use a single space between tokens.</li> </ul> <p>Examples (today is 2025-10-26): - <code>/worklog_entry 2025-10-25 \"Wrapped up feature X; reviewed PR #123\"</code> - <code>/worklog_entry \"last 2 days\" \"Pair-programmed on the parser; validated caching behavior\"</code> - <code>/worklog_entry 2025-10-20..2025-10-26</code></p> <p>Expected tool calls (handled by your assistant): - get_tracked_repositories_config - get_commits_by_date (per repo) - get_enriched_commits (optional) - get_recent_conversations - get_remote_origin \u2192 determine_commit_url_prefix - append_to_markdown (once per date)</p>"},{"location":"reference/prompts/#conversation_summary","title":"conversation_summary","text":"<ul> <li>Purpose: Create a concise summary of the current task/conversation and persist it by calling the <code>record_conversation_summary</code> tool.</li> <li>Arguments:</li> <li>date (string, optional): ISO calendar date (YYYY-MM-DD). If omitted/blank, the server resolves it to today's local date when rendering the prompt.</li> <li>title (string, optional): Title used when creating a new conversation. If not provided and <code>conversation_id</code> is null, the LLM should derive a short title from the first sentence (&lt;= 80 chars, no newlines).</li> <li>conversation_id (integer, optional): Existing conversation id to append the summary to; when provided, <code>title</code> is ignored.</li> <li>inputs (string, optional): Notes, highlights, or raw text to base the summary on.</li> <li>Behavior highlights:</li> <li>The prompt instructs the LLM to write a brief summary (bullets or short sentences) emphasizing goals, key decisions, outcomes, blockers, and next steps.</li> <li>Immediately after writing the summary, the LLM must call <code>record_conversation_summary</code> with the resolved parameters, using the server-injected date to avoid ambiguity.</li> <li>Returns: list of messages like [{\"role\": \"system\"|\"user\", \"content\": \"...\"}] suitable for your LLM client.</li> <li>See code: seev.prompts.conversation_summary_prompt.</li> </ul>"},{"location":"reference/prompts/#slash-command-usage_1","title":"Slash command usage","text":"<ul> <li>Syntax: <code>/conversation_summary &lt;date|\"\"&gt; &lt;title|\"\"&gt; &lt;conversation_id|\"\"&gt; &lt;inputs|\"\"&gt;</code></li> <li>Positional arguments, left-to-right. You may omit trailing optional arguments entirely.</li> <li>Use an empty quoted string \"\" as a placeholder to skip an earlier argument (e.g., blank date means \"use today\").</li> <li>Quoting: wrap strings with spaces in quotes. Double or single quotes are both allowed.</li> <li>Spacing: use a single space between tokens.</li> </ul> <p>Examples (today is 2025-10-26): - <code>/conversation_summary \"\" \"Cache rollout\" \"\" \"Finished caching layer; decided on Redis; add integration tests next\"</code> - <code>/conversation_summary 2025-10-26 \"Cache rollout\" \"\" \"Finished caching layer; decided on Redis; add integration tests next\"</code> - <code>/conversation_summary 2025-10-26 \"\" 42 \"Short update\"</code></p> <p>Rules your assistant should follow (already encoded in the prompt): - Make exactly one tool call to <code>record_conversation_summary</code>. - If <code>conversation_id</code> is provided, ignore title derivation. - If both <code>conversation_id</code> and <code>title</code> are omitted (i.e., both placeholders are empty), derive a short title from the first sentence (\u2264 80 chars).</p>"}]}